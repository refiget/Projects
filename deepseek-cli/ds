#!/usr/bin/env python3
import os
import sys
import re
import argparse
from datetime import datetime
from openai import OpenAI

# ========== 配置区域 ==========
API_KEY = os.getenv("DEEPSEEK_API_KEY")
BASE_URL = "https://api.deepseek.com"
LOG_FILE = os.path.expanduser("~/Projects/deepseek-cli/chat_history.txt")

# ========== Dracula 配色表 ==========
COLOR_TEXT = "\033[96m"  # 普通回答颜色（青色）

DRACULA_PURPLE = "\033[95m"
DRACULA_PINK = "\033[91m"
DRACULA_GREEN = "\033[92m"
DRACULA_YELLOW = "\033[93m"
DRACULA_CYAN = "\033[96m"
DRACULA_COMMENT = "\033[90m"
RESET = "\033[0m"


# ========== Dracula 语法高亮逻辑 ==========
def apply_dracula_theme(code: str) -> str:
    # 1. 字符串 (Green)
    code = re.sub(r"(['\"].*?['\"])", DRACULA_GREEN + r"\1" + RESET, code)

    # 2. 注释 (Grey)
    code = re.sub(r"(#.*)", DRACULA_COMMENT + r"\1" + RESET, code)

    # 3. 关键字组 A (Purple)
    kw_purple = r"\b(def|class|import|from|as|try|except|finally|with|pass|lambda|async|await)\b"
    code = re.sub(kw_purple, DRACULA_PURPLE + r"\1" + RESET, code)

    # 4. 关键字组 B (Pink)
    kw_pink = r"\b(if|elif|else|for|while|return|break|continue|in|is|not|and|or|raise|assert)\b"
    code = re.sub(kw_pink, DRACULA_PINK + r"\1" + RESET, code)

    # 5. 特殊常量 (Purple)
    kw_const = r"\b(True|False|None|self)\b"
    code = re.sub(kw_const, DRACULA_PURPLE + r"\1" + RESET, code)

    # 6. 数字 (Yellow)
    code = re.sub(r"\b(\d+)\b", DRACULA_YELLOW + r"\1" + RESET, code)

    # 7. 函数调用 (Yellow)
    code = re.sub(r"(\w+)(?=\()", DRACULA_YELLOW + r"\1" + RESET, code)

    return code


# ========== 渲染代码块 ==========
def render_content(full_text: str):
    """
    对回复中的 ```python ... ``` 部分做 Dracula 染色，其余内容用 COLOR_TEXT 输出
    """
    parts = re.split(r"(```python.*?```)", full_text, flags=re.S)

    for part in parts:
        if part.startswith("```python") and part.endswith("```"):
            raw_code = part[9:-3]
            highlighted = apply_dracula_theme(raw_code)
            print(f"{DRACULA_COMMENT}```python{RESET}")
            print(highlighted.strip())
            print(f"{DRACULA_COMMENT}```{RESET}")
        else:
            if part.strip():
                print(COLOR_TEXT + part + RESET, end="")


# ========== 保存日志 ==========
def save_dialogue(prompt: str, response: str, mode: str):
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    # 去掉 ANSI 颜色码，避免日志乱码
    clean_resp = re.sub(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])", "", response)
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(f"[{ts}] MODE={mode}\nQ: {prompt}\nA: {clean_resp}\n" + "-" * 40 + "\n")


# ========== 构造不同模式下的 system 提示 ==========
def build_system_prompt(mode: str) -> str:
    if mode == "spell":
        # 拼写纠错 / 猜词助手
        return (
            "你是一个英文拼写纠错和单词猜测助手。"
            "用户会输入一个或多个可能拼错的英文单词或短语。"
            "你需要输出：1) 修正后的正确拼写 2) 简短中文解释。"
            "回答要非常简洁，尽量一行搞定。"
        )
    elif mode == "trans":
        # 中英翻译助手（优先中->英）
        return (
            "你是一个中英互译助手。"
            "如果输入主要是中文，请翻译成自然流畅的英文；"
            "如果输入主要是英文，请翻译成自然的中文。"
            "只输出翻译结果，不要解释。"
        )
    else:
        # 默认：Python + nvim CLI 助手
        return (
            "你是运行在 CLI 环境的 Python 和 Neovim 专家，"
            "所有回答都要适合终端阅读,且回答简洁。"
            "如果用户明确要代码，你要优先给出可运行的 Python 代码，"
            "并尽量使用行尾注释 (inline comments)。"
        )


# ========== 主聊天逻辑 ==========
def chat(prompt: str, mode: str = "normal"):
    if not API_KEY:
        print("ERROR: DEEPSEEK_API_KEY not set")
        return

    client = OpenAI(api_key=API_KEY, base_url=BASE_URL)

    system_prompt = build_system_prompt(mode)

    try:
        response = client.chat.completions.create(
            model="deepseek-chat",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": prompt},
            ],
            stream=True,
        )

        print()
        full_content = ""

        # 流式打印原始回答（青色）
        print(COLOR_TEXT, end="")
        for chunk in response:
            delta = chunk.choices[0].delta.content
            if delta:
                full_content += delta
                print(delta, end="", flush=True)
        print(RESET + "\n")

        # 只有在 normal 模式下，才额外做 Python 代码块 Dracula 渲染
        if mode == "normal" and "```python" in full_content:
            print(f"{DRACULA_COMMENT}--- Dracula Theme Rendering ---{RESET}\n")
            render_content(full_content)
            print("\n")

        save_dialogue(prompt, full_content, mode)

    except Exception as e:
        print(f"Error: {e}")


# ========== 主程序入口 ==========
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("prompt", nargs="*", help="Question")
    parser.add_argument(
        "--spell",
        action="store_true",
        help="启用拼写纠错 / 猜词模式 (英文)",
    )
    parser.add_argument(
        "--trans",
        action="store_true",
        help="启用中英翻译模式",
    )
    args = parser.parse_args()

    # 命令行一次性调用：支持
    #   ds --spell worng
    #   ds --trans 你好世界
    #   ds 正常问题
    mode = "normal"
    if args.spell:
        mode = "spell"
    if args.trans:
        mode = "trans"

    if args.prompt:
        chat(" ".join(args.prompt), mode=mode)
        return

    # 交互模式下，加入前缀指令：
    #   /s xxx   -> spell 模式
    #   /t xxx   -> translate 模式
    print(f"{COLOR_TEXT}=== DeepSeek CLI (Dracula) ==={RESET}")
    print(f"{DRACULA_COMMENT}提示: /s 单词 进行拼写纠错，/t 句子 进行中英翻译{RESET}")
    while True:
        try:
            print(f"\n{DRACULA_PINK}>>>{RESET} ", end="")
            q = input().strip()
            if not q:
                continue
            if q.lower() in ("exit", "quit"):
                break

            # 前缀指令模式
            if q.startswith("/s "):
                chat(q[3:].strip(), mode="spell")
            elif q.startswith("/t "):
                chat(q[3:].strip(), mode="trans")
            else:
                chat(q, mode="normal")
        except KeyboardInterrupt:
            print("\nBye!")
            break


if __name__ == "__main__":
    main()
